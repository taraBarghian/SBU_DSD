var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[0.401032, 0.268258, 0.159235, 0, 0], "total":[2292, 2721, 0, 0], "name":"System", "max_resources":[854400, 1708800, 2713, 1518], "children":[{"name":"count", "compute_units":1, "type":"function", "total_percent":[0.401032, 0.268258, 0.159235, 0, 0], "total_kernel_resources":[2292, 2721, 0, 0], "details":[{"type":"text", "text":"Number of compute units: 1"}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 128 bits wide with a buffer size of 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}]}, {"name":"Variable: \\n - \'sum\' (counter.cpp:12)", "type":"resource", "data":[24, 101, 0, 0], "debug":[[{"filename":"counter.cpp", "line":12}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'y\' (counter.cpp:10)", "type":"resource", "data":[7, 36, 0, 0], "debug":[[{"filename":"counter.cpp", "line":10}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"Variable: \\n - \'z\' (counter.cpp:11)", "type":"resource", "data":[7, 36, 0, 0], "debug":[[{"filename":"counter.cpp", "line":11}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 1"}]}, {"name":"count.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[0, 320, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[0, 64, 0, 0]}, {"name":"counter.cpp:10", "type":"resource", "data":[0, 32, 0, 0], "debug":[[{"filename":"counter.cpp", "line":10}]]}, {"name":"counter.cpp:11", "type":"resource", "data":[0, 96, 0, 0], "debug":[[{"filename":"counter.cpp", "line":11}]]}, {"name":"counter.cpp:18", "type":"resource", "data":[0, 64, 0, 0], "debug":[[{"filename":"counter.cpp", "line":18}]]}, {"name":"counter.cpp:19", "type":"resource", "data":[0, 64, 0, 0], "debug":[[{"filename":"counter.cpp", "line":19}]]}]}, {"name":"Feedback", "type":"resource", "data":[5, 2, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 2, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[1, 0, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Read", "type":"resource", "count":1, "data":[1, 0, 0, 0]}]}, {"name":"counter.cpp:10", "type":"resource", "data":[249, 221, 0, 0], "debug":[[{"filename":"counter.cpp", "line":10}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[249, 221, 0, 0], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}]}], "replace_name":"true"}, {"name":"counter.cpp:11", "type":"resource", "data":[249, 221, 0, 0], "debug":[[{"filename":"counter.cpp", "line":11}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[249, 221, 0, 0], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}]}], "replace_name":"true"}, {"name":"counter.cpp:18", "type":"resource", "data":[498, 442, 0, 0], "debug":[[{"filename":"counter.cpp", "line":18}]], "children":[{"name":"Load", "type":"resource", "count":2, "data":[498, 442, 0, 0], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}]}], "replace_name":"true"}, {"name":"counter.cpp:19", "type":"resource", "data":[498, 442, 0, 0], "debug":[[{"filename":"counter.cpp", "line":19}]], "children":[{"name":"Load", "type":"resource", "count":2, "data":[498, 442, 0, 0], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}]}], "replace_name":"true"}]}]}, {"name":"count.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[19, 99, 0, 0], "details":[{"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[19, 35, 0, 0]}, {"name":"counter.cpp:18", "type":"resource", "data":[0, 32, 0, 0], "debug":[[{"filename":"counter.cpp", "line":18}]]}, {"name":"counter.cpp:19", "type":"resource", "data":[0, 32, 0, 0], "debug":[[{"filename":"counter.cpp", "line":19}]]}]}, {"name":"Feedback", "type":"resource", "data":[88, 218, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0]}, {"name":"counter.cpp:10", "type":"resource", "data":[0.5, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":10}]]}, {"name":"counter.cpp:11", "type":"resource", "data":[0.5, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":11}]]}, {"name":"counter.cpp:12", "type":"resource", "data":[0.5, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":12}]]}, {"name":"counter.cpp:15", "type":"resource", "data":[23, 22.5, 0, 0], "debug":[[{"filename":"counter.cpp", "line":15}]]}, {"name":"counter.cpp:17", "type":"resource", "data":[24.5, 101, 0, 0], "debug":[[{"filename":"counter.cpp", "line":17}]]}, {"name":"counter.cpp:18", "type":"resource", "data":[7.5, 36, 0, 0], "debug":[[{"filename":"counter.cpp", "line":18}]]}, {"name":"counter.cpp:19", "type":"resource", "data":[7.5, 36, 0, 0], "debug":[[{"filename":"counter.cpp", "line":19}]]}, {"name":"counter.cpp:20", "type":"resource", "data":[23, 22.5, 0, 0], "debug":[[{"filename":"counter.cpp", "line":20}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[44, 28, 0, 0], "details":[{"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"counter.cpp:10", "type":"resource", "data":[13, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":10}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[13, 0, 0, 0]}], "replace_name":"true"}, {"name":"counter.cpp:11", "type":"resource", "data":[13, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":11}]], "children":[{"name":"Select", "type":"resource", "count":1, "data":[13, 0, 0, 0]}], "replace_name":"true"}, {"name":"counter.cpp:15", "type":"resource", "data":[9.5, 0.5, 0, 0], "debug":[[{"filename":"counter.cpp", "line":15}]], "children":[{"name":"6-bit Integer Add", "type":"resource", "count":1, "data":[3.5, 0, 0, 0]}, {"name":"And", "type":"resource", "count":3, "data":[0.5, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":3, "data":[5.5, 0.5, 0, 0]}], "replace_name":"true"}, {"name":"counter.cpp:17", "type":"resource", "data":[33, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":17}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[33, 0, 0, 0]}], "replace_name":"true"}, {"name":"counter.cpp:18", "type":"resource", "data":[167, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":18}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[132, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[13, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":2, "data":[22, 0, 0, 0]}], "replace_name":"true"}, {"name":"counter.cpp:19", "type":"resource", "data":[167, 0, 0, 0], "debug":[[{"filename":"counter.cpp", "line":19}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":4, "data":[132, 0, 0, 0]}, {"name":"Select", "type":"resource", "count":1, "data":[13, 0, 0, 0]}, {"name":"Xor", "type":"resource", "count":2, "data":[22, 0, 0, 0]}], "replace_name":"true"}, {"name":"counter.cpp:20", "type":"resource", "data":[9.5, 0.5, 0, 0], "debug":[[{"filename":"counter.cpp", "line":20}]], "children":[{"name":"6-bit Integer Add", "type":"resource", "count":1, "data":[3.5, 0, 0, 0]}, {"name":"And", "type":"resource", "count":3, "data":[0.5, 0, 0, 0]}, {"name":"Integer Compare", "type":"resource", "count":3, "data":[5.5, 0.5, 0, 0]}], "replace_name":"true"}]}]}, {"name":"count.B3", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[3, 8, 0, 0], "details":[{"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3, 8, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[3, 2, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"Channel Write", "type":"resource", "count":1, "data":[3, 2, 0, 0]}]}, {"name":"counter.cpp:21", "type":"resource", "data":[92, 272, 0, 0], "debug":[[{"filename":"counter.cpp", "line":21}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[92, 272, 0, 0], "details":[{"type":"text", "text":"Store uses a Local-pipelined LSU"}]}], "replace_name":"true"}, {"name":"counter.cpp:22", "type":"resource", "data":[92, 272, 0, 0], "debug":[[{"filename":"counter.cpp", "line":22}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[92, 272, 0, 0], "details":[{"type":"text", "text":"Store uses a Local-pipelined LSU"}]}], "replace_name":"true"}]}]}]}]}';
var area_srcJSON='{"children":[{"children":[{"data":[141,256,0,0],"detail":[{"text":"Feedback + Cluster logic","type":"text"}],"name":"Data control overhead","type":"resource"},{"data":[0,0,0,0],"details":[{"text":"Stream implemented 128 bits wide with a buffer size of 0 elements.","type":"text"}],"name":"Component call","type":"resource"},{"data":[0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"}],"name":"Component return","type":"resource"},{"data":[24,101,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}],"name":"Variable: \\n - \'sum\' (counter.cpp:12)","type":"resource"},{"data":[7,36,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}],"name":"Variable: \\n - \'y\' (counter.cpp:10)","type":"resource"},{"data":[7,36,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 1","type":"text"}],"name":"Variable: \\n - \'z\' (counter.cpp:11)","type":"resource"},{"children":[{"count":2,"data":[19,99,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":1,"data":[1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"Channel Read","type":"resource"},{"count":1,"data":[3,2,0,0],"debug":[[{"filename":"","line":0}]],"name":"Channel Write","type":"resource"}],"data":[23,101,0,0],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[0,32,0,0],"debug":[[{"filename":"counter.cpp","line":10}]],"name":"State","type":"resource"},{"count":1,"data":[249,221,0,0],"debug":[[{"filename":"counter.cpp","line":10}]],"name":"Load","type":"resource"},{"count":1,"data":[13,0,0,0],"debug":[[{"filename":"counter.cpp","line":10}]],"name":"Select","type":"resource"}],"data":[262,253,0,0],"debug":[[{"filename":"counter.cpp","line":10}]],"name":"counter.cpp:10","type":"resource"},{"children":[{"count":1,"data":[0,96,0,0],"debug":[[{"filename":"counter.cpp","line":11}]],"name":"State","type":"resource"},{"count":1,"data":[249,221,0,0],"debug":[[{"filename":"counter.cpp","line":11}]],"name":"Load","type":"resource"},{"count":1,"data":[13,0,0,0],"debug":[[{"filename":"counter.cpp","line":11}]],"name":"Select","type":"resource"}],"data":[262,317,0,0],"debug":[[{"filename":"counter.cpp","line":11}]],"name":"counter.cpp:11","type":"resource"},{"children":[{"count":2,"data":[0,96,0,0],"debug":[[{"filename":"counter.cpp","line":18}]],"name":"State","type":"resource"},{"count":2,"data":[498,442,0,0],"debug":[[{"filename":"counter.cpp","line":18}]],"name":"Load","type":"resource"},{"count":4,"data":[132,0,0,0],"debug":[[{"filename":"counter.cpp","line":18}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[13,0,0,0],"debug":[[{"filename":"counter.cpp","line":18}]],"name":"Select","type":"resource"},{"count":2,"data":[22,0,0,0],"debug":[[{"filename":"counter.cpp","line":18}]],"name":"Xor","type":"resource"}],"data":[665,538,0,0],"debug":[[{"filename":"counter.cpp","line":18}]],"name":"counter.cpp:18","type":"resource"},{"children":[{"count":2,"data":[0,96,0,0],"debug":[[{"filename":"counter.cpp","line":19}]],"name":"State","type":"resource"},{"count":2,"data":[498,442,0,0],"debug":[[{"filename":"counter.cpp","line":19}]],"name":"Load","type":"resource"},{"count":4,"data":[132,0,0,0],"debug":[[{"filename":"counter.cpp","line":19}]],"name":"32-bit Integer Add","type":"resource"},{"count":1,"data":[13,0,0,0],"debug":[[{"filename":"counter.cpp","line":19}]],"name":"Select","type":"resource"},{"count":2,"data":[22,0,0,0],"debug":[[{"filename":"counter.cpp","line":19}]],"name":"Xor","type":"resource"}],"data":[665,538,0,0],"debug":[[{"filename":"counter.cpp","line":19}]],"name":"counter.cpp:19","type":"resource"},{"children":[{"count":1,"data":[3.5,0,0,0],"debug":[[{"filename":"counter.cpp","line":15}]],"name":"6-bit Integer Add","type":"resource"},{"count":3,"data":[0.5,0,0,0],"debug":[[{"filename":"counter.cpp","line":15}]],"name":"And","type":"resource"},{"count":3,"data":[5.5,0.5,0,0],"debug":[[{"filename":"counter.cpp","line":15}]],"name":"Integer Compare","type":"resource"}],"data":[9.5,0.5,0,0],"debug":[[{"filename":"counter.cpp","line":15}]],"name":"counter.cpp:15","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[33,0,0,0],"debug":[[{"filename":"counter.cpp","line":17}]],"name":"32-bit Integer Add","type":"resource"}],"data":[33,0,0,0],"debug":[[{"filename":"counter.cpp","line":17}]],"name":"counter.cpp:17","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3.5,0,0,0],"debug":[[{"filename":"counter.cpp","line":20}]],"name":"6-bit Integer Add","type":"resource"},{"count":3,"data":[0.5,0,0,0],"debug":[[{"filename":"counter.cpp","line":20}]],"name":"And","type":"resource"},{"count":3,"data":[5.5,0.5,0,0],"debug":[[{"filename":"counter.cpp","line":20}]],"name":"Integer Compare","type":"resource"}],"data":[9.5,0.5,0,0],"debug":[[{"filename":"counter.cpp","line":20}]],"name":"counter.cpp:20","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[92,272,0,0],"debug":[[{"filename":"counter.cpp","line":21}]],"name":"Store","type":"resource"}],"data":[92,272,0,0],"debug":[[{"filename":"counter.cpp","line":21}]],"name":"counter.cpp:21","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[92,272,0,0],"debug":[[{"filename":"counter.cpp","line":22}]],"name":"Store","type":"resource"}],"data":[92,272,0,0],"debug":[[{"filename":"counter.cpp","line":22}]],"name":"counter.cpp:22","replace_name":"true","type":"resource"}],"compute_units":1,"data":[2292,2721,0,0],"debug":[[{"filename":"counter.cpp","line":10}]],"details":[{"text":"Number of compute units: 1","type":"text"}],"name":"count","total_kernel_resources":[2292,2721,0,0],"total_percent":[0.401032,0.268258,0.159235,0,0],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","Details"],"data":[2292,2721,0,0],"debug_enabled":"true","max_resources":[854400,1708800,2713,1518],"name":"System","total":[2292,2721,0,0],"total_percent":[0.401032,0.268258,0.159235,0,0],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"count", "children":[{"type":"bb", "id":3, "name":"count.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"count.B1.start", "children":[{"type":"inst", "id":7, "name":"Channel Read", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"2", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":9, "name":"Load", "debug":[[{"filename":"counter.cpp", "line":10}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"v", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":10, "name":"Load", "debug":[[{"filename":"counter.cpp", "line":18}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"k", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":11, "name":"Load", "debug":[[{"filename":"counter.cpp", "line":11}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"v", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":12, "name":"Load", "debug":[[{"filename":"counter.cpp", "line":18}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"k", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":13, "name":"Load", "debug":[[{"filename":"counter.cpp", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"k", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":14, "name":"Load", "debug":[[{"filename":"counter.cpp", "line":19}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"k", "Start Cycle":"2", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":19, "name":"loop", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"22"}]}, {"type":"inst", "id":20, "name":"end", "details":[{"type":"table", "Start Cycle":"34", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"34", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":5, "name":"count.B2", "details":[{"type":"table", "Latency":"5", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"", "Loops To":"5"}]}, {"type":"bb", "id":6, "name":"count.B3", "children":[{"type":"inst", "id":15, "name":"Store", "debug":[[{"filename":"counter.cpp", "line":21}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"v", "Start Cycle":"0", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":16, "name":"Store", "debug":[[{"filename":"counter.cpp", "line":22}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"v", "Start Cycle":"0", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Load-Store Units", "link":"https://www.altera.com/documentation/mwh1391807516407.html#yeo1491314105959"}]}]}]}, {"type":"inst", "id":17, "name":"Channel Write", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"31", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Best Practices Guide : Channels", "link":"https://www.altera.com/documentation/mwh1391807516407.html#qah1476410829821"}]}]}]}, {"type":"inst", "id":21, "name":"begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":22, "name":"loop end", "details":[{"type":"table", "Start Cycle":"32", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"32", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}]}, {"type":"memtype", "id":1, "name":"System Memory", "children":[{"type":"memsys", "id":25, "name":"0", "details":[{"type":"table", "Number of banks":"1", "Arguments from count":"v, k"}]}]}, {"type":"stream", "id":8, "name":"do", "debug":[[{"filename":"counter.cpp", "line":8}]], "details":[{"type":"table", "Width":"128 bits", "Depth":"0", "Bits per symbol":"128 bits", "Uses Packets":"No", "Uses Valid":"Yes"}]}, {"type":"stream", "id":18, "name":"return", "debug":[[{"filename":"counter.cpp", "line":8}]], "details":[{"type":"table", "Width":"8 bits", "Depth":"0", "Bits per symbol":"8 bits", "Uses Packets":"No", "Uses Ready":"Yes"}]}, {"type":"interface", "id":24, "name":"k", "debug":[[{"filename":"counter.cpp", "line":8}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"count"}]}, {"type":"interface", "id":23, "name":"v", "debug":[[{"filename":"counter.cpp", "line":8}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"count"}]}], "links":[{"from":8, "to":7}, {"from":17, "to":18}, {"from":23, "to":7}, {"from":24, "to":7}, {"from":22, "to":19}, {"from":3, "to":19}, {"from":7, "to":20}, {"from":9, "to":20}, {"from":10, "to":20}, {"from":11, "to":20}, {"from":12, "to":20}, {"from":13, "to":20}, {"from":14, "to":20}, {"from":5, "to":5}, {"from":20, "to":5}, {"from":5, "to":21}, {"from":15, "to":22}, {"from":16, "to":22}, {"from":17, "to":22}, {"from":19, "to":7}, {"from":7, "to":9}, {"from":7, "to":10}, {"from":7, "to":11}, {"from":7, "to":12}, {"from":7, "to":13}, {"from":7, "to":14}, {"from":21, "to":15}, {"from":21, "to":16}, {"from":15, "to":17}, {"from":16, "to":17}, {"from":16, "to":25}, {"from":25, "to":9}, {"from":25, "to":11}, {"from":25, "to":10}, {"from":25, "to":13}, {"from":25, "to":12}, {"from":25, "to":14}, {"from":15, "to":25}]}';
var lmvJSON='{"nodes":[{"type":"interface", "id":24, "name":"k", "debug":[[{"filename":"counter.cpp", "line":8}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"count"}]}, {"type":"interface", "id":23, "name":"v", "debug":[[{"filename":"counter.cpp", "line":8}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"count"}]}], "links":[]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Bottleneck", "Details"], "children":[{"name":"Component: count", "data":["", "", ""], "debug":[[{"filename":"counter.cpp", "line":8}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}], "children":[{"name":"count.B1.start", "data":["Yes", ">=1", "n/a"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Run simulation to verify component\'s dynamic II. Use the %L report to view results. II is an approximation due to variable inner loop trip count.", "links":[{"view":"Verification statistics"}]}], "children":[{"name":"count.B2", "data":["Yes", "1", "n/a"], "debug":[[{"filename":"counter.cpp", "line":15}], [{"filename":"counter.cpp", "line":20}]], "children":[]}]}]}]}';
var summaryJSON='{"estimatedResources":{"name":"Estimated Resource Usage", "columns":["Component Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs "], "children":[{"name":"count", "data":[2292, 2721, 0, 0], "debug":[[{"filename":"counter.cpp", "line":8}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[2292, 2721, 0, 0], "data_percent":[0.268258, 0.159235, 0, 0]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[854400, 1708800, 2713, 1518]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"name":"Project Name","data":["./test-fpga"],"classes":["info-table"]},{"name":"Target Family, Device","data":["Arria 10, 10AX115U1F45I1SG"]},{"name":"i++ Version","data":["19.1.0 Build 670"]},{"name":"Quartus Version","data":["19.1.0 Build 670"]},{"name":"Command","data":["i++ -march=Arria10 counter.cpp -o test-fpga.exe"]},{"name":"Reports Generated At", "data":["Sun Jun 27 12:28:52 2021"]}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{  "name":"Quartus Fit Clock Summary"  ,"columns":["", "1x clock fmax"]  ,"children":[  {    "name":"Frequency (MHz)","data":[76.12]  }]},"quartusFitResourceUsageSummary":{  "name":"Quartus Fit Resource Utilization Summary"  ,"columns":["", "ALMs", "FFs", "RAMs", "DSPs"]  ,"children":[  {"name":"count","data":[1714.0 ,3272 ,24 ,0]  }]}}';
var fileJSON=[{"path":"counter.cpp", "name":"counter.cpp", "has_active_debug_locs":true, "absName":"d:/intelFPGA/19.1/hls/examples/Proj/counter.cpp", "content":"#include \"HLS/hls.h\"\012#include <stdio.h>\012#include <stdint.h>\012\012using namespace ihc;\012\012component void count(uint32_t v[2], uint32_t k[4])\012{\012\012	uint32_t  y = v[0];\012	uint32_t  z = v[1];\012	uint32_t  sum = 0; /* set up */\012	uint32_t  delta = 0x9e3779b9; /* a key schedule constant */\012	int n = 32;\012	while (n-->0)\012	{ /* basic cycle start */\012		sum += delta;\012		y += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\012		z += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\012	}\012	v[0] = y;\012	v[1] = z;\012\012}\012\012int main() {\012\012	uint32_t  v[2] = { 0xFFFFFFFF,0xFFFFFFFF };\012	uint32_t  k[4] = { 0,0,0,0 };\012	count(v, k);\012\012\012\012 \012  bool pass = false;\012  if(v[1]==0x1335b5b8 && v[0]==0xf6f4bf6e){\012  	pass = true;\012  }\012\012  if (pass) {\012    printf(\"PASSED\\n\");\012  }\012  else {\012    printf(\"FAILED\\n\");\012  }\012\012  return 0;\012\012}\012\012"}, {"path":"D:/intelFPGA/19.1/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"d:/intelFPGA/19.1/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifndef __INTELFPGA_COMPILER__\012#ifndef component\012#define component\012#endif\012#define HLS_X86\012#endif\012\012#include \"HLS/hls_internal.h\"\012\012/* Deprecated APIs and names after intel rebranding */\012#ifdef __IHC_USE_DEPRECATED_NAMES\012#pragma message \"Warning: Enabling deprecated names - these names will not be supported in future releases.\"\012namespace ihc {}\012namespace altera = ihc;\012#define altera_hls_component_run_all ihc_hls_component_run_all\012#define altera_fence ihc_fence\012#define altera_hls_get_sim_time ihc_hls_get_sim_time\012#define altera_hls_enqueue ihc_hls_enqueue\012#define altera_hls_enqueue_noret ihc_hls_enqueue_noret\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012\012// Memory attribute macros\012#define hls_simple_dual_port_memory hls_memory hls_singlepump hls_numports_readonly_writeonly(1,1)\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012template <int n>         class dwidth:public internal::param {};\012template <int n>         class awidth:public internal::param {};\012template <int n>         class latency: public internal::param {};\012template <readwrite_t n> class readwrite_mode: public internal::param{}; // declared in hls_internal.h as enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012template <int n>         class maxburst: public internal::param {};\012template <int n>         class align: public internal::param {};\012template <int n>         class aspace: public internal::param {};\012template <bool n>        class waitrequest: public internal::param{};\012\012template <typename DT, typename p1 = internal::notinit, typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit, typename p6 = internal::notinit, typename p7 = internal::notinit, typename p8 = internal::notinit>\012class mm_master\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false):internal::memory_base(data,size,sizeof(DT),use_socket) {\012  }\012#else\012  template<typename T> explicit mm_master(T *data, int size=0, bool use_socket=false);\012#endif\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  DT &operator[](int index);\012  DT &operator*();\012  DT *operator->();\012  template<typename T> operator T();\012  DT *operator+(int index);\012  template<typename T> DT *operator&(T value);\012  template<typename T> DT *operator|(T value);\012  template<typename T> DT *operator^(T value);\012  // This function is only supported in the testbench:\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012  // The copy constructor and assignment operator are necessary to ensure\012  // new_masters doesn't get copied.\012  mm_master(const mm_master &other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  mm_master& operator=(const mm_master& other) {\012    mem = other.mem;\012    size = other.size;\012    data_size = other.data_size;\012    use_socket = other.use_socket;\012  }\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012private:\012  std::vector<internal::memory_base* > new_masters;\012#endif\012\012};\012\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012template <int n> class buffer:public internal::param {};\012template <int n> class readyLatency:public internal::param {};\012template <int n> class bitsPerSymbol:public internal::param {};\012template <bool b> class usesPackets:public internal::param {};\012template <bool b> class usesValid:public internal::param {};\012template <bool b> class usesReady:public internal::param {};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_in : public internal::stream<T,p1,p2,p3,p4,p5> {\012public:\012  stream_in();\012  T read();\012  void write(T arg);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012};\012\012template <typename T, typename p1 = internal::notinit , typename p2 = internal::notinit, typename p3 = internal::notinit, typename p4 = internal::notinit, typename p5 = internal::notinit>\012class stream_out : public internal::stream<T,p1,p2,p3,p4,p5> {\012\012public:\012  stream_out();\012  T read();\012  void write(T);\012  T tryRead(bool &success);\012  bool tryWrite(T arg);\012\012  // for packet based stream\012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {};\012\012#else\012extern \"C\" void mem_fence(int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((DT*)mem)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*() {\012  return ((DT*)mem)[0];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)mem;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)mem);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>& mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::getInterfaceAtIndex(int index) {\012  assert(size==0 || index*data_size<size);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8> *temp = new mm_master(&(((DT*)mem)[index]), size - index * sizeof(DT), use_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_in<T,p1,p2,p3,p4,p5>::stream_in() {}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_in<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_in<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_in<T,p1,p2,p3,p4,p5>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012stream_out<T,p1,p2,p3,p4,p5>::stream_out() {\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read() {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read();\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !internal::stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty();\012  if (success) {\012    return read(sop, eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream_out<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012    T elem = internal::stream<T,p1,p2,p3,p4,p5>::read(sop, eop);\012    return elem;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    internal::stream<T,p1,p2,p3,p4,p5>::write(arg, sop, eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream_out<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream_out<T,p1,p2,p3,p4,p5>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(average_ready, ready_delta);\012}\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator[](int index) {\012  return ((DT*)this)[index];\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT &mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator*(){\012  return *((DT*)this);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator->() {\012  return (DT*)this;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator+(int index) {\012  return ((DT*)this)+index;\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator T() {\012  return (T)((unsigned long long)this);\012}\012\012// Bitwise operators\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator&(T value) {\012  return (DT*)((unsigned long long)this & (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator|(T value) {\012  return (DT*)((unsigned long long)this | (unsigned long long)value);\012}\012\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8>\012template<typename T> DT *mm_master<DT, p1, p2, p3, p4, p5, p6, p7, p8>::operator^(T value) {\012  return (DT*)((unsigned long long)this ^ (unsigned long long)value);\012}\012\012#endif\012} // namespace ihc\012\012#endif\012\012"}, {"path":"D:/intelFPGA/19.1/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":false, "absName":"d:/intelFPGA/19.1/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#endif\012#include <stdio.h>\012#include <stdlib.h>\012\012#if defined(__clang__) //our llvm defines _MSC_VER so check this first\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#elif defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012namespace ihc {\012// Forward declarations so I can make them friends\012template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> class mm_master;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_in;\012template <typename T, typename p1, typename p2, typename p3, typename p4, typename p5> class stream_out;\012\012namespace internal {\012\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  \012  size_t sim_base;\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  ~memory_base() {}; // Cannot inherit from HLS interface\012  template <typename DT, typename p1, typename p2, typename p3, typename p4, typename p5, typename p6, typename p7, typename p8> friend class ::ihc::mm_master;\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(void *mem, size_t size, size_t data_size, bool use_socket):data_size(data_size),mem(mem),size(size),use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012\012  void set_parameters(int aspace, int awidth, int dwidth,  int latency, readwrite_t readwrite_mode, bool byteenabled, int maxburst, int align, bool waitrequest );\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() {return aspace;}\012  void * get_base(){return mem;}\012  size_t get_size() {return size;}\012  int get_awidth() {return awidth;}\012  int get_dwidth() {return dwidth;}\012  int get_latency() {return latency;}\012  readwrite_t get_readwrite_mode() {return readwrite_mode;}\012  bool get_byteenabled() {return byteenabled;}\012  int get_maxburst() {return maxburst;}\012  int get_align() {return align;}\012  bool get_waitrequest() {return waitrequest;}\012  \012  size_t get_data_size() {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base() {return sim_base;}\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, typename p1 = notinit, typename p2 = notinit, typename p3 = notinit, typename p4 = notinit, typename p5 = notinit>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012   ~stream() {} // Cannot inherit from HLS interface\012  //Make sure only the listed classes can reach the destructor, and nothing derived from them\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_in;\012  template <typename T1, typename p11, typename p21, typename p31, typename p41, typename p51> friend class ihc::stream_out;\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012#endif\012  \012protected:\012  stream();\012  \012#ifdef HLS_X86\012  stream(const stream<T,p1,p2,p3,p4,p5>& copy_from);\012#endif\012  \012public:     \012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read();               \012  virtual void write(T arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(T arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop);\012  virtual void write(T arg, bool sop, bool eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual bool tryWrite(T arg, bool sop, bool eop);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(T arg);      \012  T tryRead(bool &success); \012  bool tryWrite(T arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  void write(T arg, bool sop, bool eop);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  bool tryWrite(T arg, bool sop, bool eop);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012#ifdef HLS_X86\012template <typename T, typename p1 , typename p2, typename p3, typename p4, typename p5>\012  stream<T,p1,p2,p3,p4,p5>::stream(const stream<T,p1,p2,p3,p4,p5>& copy_from):stream_abstract_base(sizeof(T)),q_(copy_from.q_),qp_(copy_from.qp_)\012{\012}\012#endif\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read();\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::tryRead(bool &success, bool& sop, bool& eop) {\012  success = !_internal_cosim_empty();\012  if (success) {\012    return read(sop,eop);\012  } else {\012    return T();\012  }\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read() {\012  T arg;      \012  \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  qp_.pop(); //unused sideband signals\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::read(bool& sop, bool& eop) {\012  T arg;\012\012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  qp_.pop(); //unused sideband signals\012  \012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front() {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012T stream<T,p1,p2,p3,p4,p5>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  bool empty = _internal_cosim_empty();\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::tryWrite(T arg, bool sop, bool eop) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg, sop, eop);\012   }\012   return success;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(false,false)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write(T arg, bool sop, bool eop) {\012    q_.push(arg);\012    qp_.push(std::pair<bool,bool>(sop, eop)); // sideband signals\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012void stream<T,p1,p2,p3,p4,p5>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012  void stream<T,p1,p2,p3,p4,p5>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012bool stream<T,p1,p2,p3,p4,p5>::stall() {\012  if (m_remaining_period > 0) {\012    m_remaining_period--;\012    if (m_remaining_period < m_period_threshold) { \012      return false;\012    } else {\012      return true;\012    }\012  }\012  setStallPeriod();\012  return false;\012}\012\012template<typename T, typename p1, typename p2, typename p3, typename p4, typename p5>\012unsigned stream<T,p1,p2,p3,p4,p5>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#endif\012\012"}];
